From aa59bc49c4bd1b5915942a35dcaa3be0ebd2eeb2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Rafael=20Tupynamb=C3=A1=20Dutra?= <rafael.rtd@gmail.com>
Date: Sun, 14 Jan 2018 18:02:00 -0800
Subject: [PATCH] Check validity of samples generated by QuickSampler.

---
 src/sat/dimacs.cpp            |  27 +++++-
 src/shell/dimacs_frontend.cpp | 210 ++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 236 insertions(+), 1 deletion(-)

diff --git a/src/sat/dimacs.cpp b/src/sat/dimacs.cpp
index 512be5f..c1393e4 100644
--- a/src/sat/dimacs.cpp
+++ b/src/sat/dimacs.cpp
@@ -21,6 +21,8 @@ Revision History:
 #undef min
 #include "sat/sat_solver.h"
 
+std::vector<int> indsup;
+
 class stream_buffer {
     std::istream & m_stream;
     int            m_val;
@@ -116,9 +118,32 @@ void parse_dimacs_core(Buffer & in, sat::solver & solver) {
         if (*in == EOF) {
             break;
         }
-        else if (*in == 'c' || *in == 'p') {
+        else if (*in == 'p') {
             skip_line(in);
         }
+        else if (*in == 'c') {
+            bool is_ind = true;
+            char ind[] = " ind";
+            for (int index = 0; index < 4; ++ index) {
+                ++in;
+                if (*in != ind[index]) {
+                    is_ind = false;
+                    break;
+                }
+            }
+            if (!is_ind) {
+                skip_line(in);
+                continue;
+            }
+            ++in;
+            int parsed_lit;
+            while (true) {
+                parsed_lit = parse_int(in);
+                if (parsed_lit == 0)
+                    break;
+                indsup.push_back(parsed_lit);
+            }
+        }
         else {
             read_clause(in, solver, lits);
             solver.mk_clause(lits.size(), lits.c_ptr());
diff --git a/src/shell/dimacs_frontend.cpp b/src/shell/dimacs_frontend.cpp
index 999574f..93332f4 100644
--- a/src/shell/dimacs_frontend.cpp
+++ b/src/shell/dimacs_frontend.cpp
@@ -17,6 +17,7 @@ Revision History:
 
 --*/
 #include<iostream>
+#include<unordered_map>
 #include<time.h>
 #include<signal.h>
 #include "util/timeout.h"
@@ -25,6 +26,14 @@ Revision History:
 #include "sat/sat_solver.h"
 #include "util/gparams.h"
 
+struct cell {
+    int c;
+    bool v;
+};
+
+extern std::vector<int> indsup;
+std::unordered_map<std::string, struct cell> hist;
+double solver_time = 0.0;
 extern bool          g_display_statistics;
 static sat::solver * g_solver = 0;
 static clock_t       g_start_time;
@@ -126,6 +135,57 @@ static void track_clauses(sat::solver const& src,
     }
 }
 
+double duration(struct timespec * a, struct timespec * b) {
+    return (b->tv_sec - a->tv_sec) + 1.0e-9 * (b->tv_nsec - a->tv_nsec);
+}
+
+bool check_sample(sat::solver & solver, std::string & line) {
+        struct timespec start;
+        clock_gettime(CLOCK_REALTIME, &start);
+
+        solver.user_push();
+        std::istringstream in(line);
+        int nmut;
+        in >> nmut;
+        char c;
+        in >> c;
+        in >> c;
+        int k = 0;
+        while(!in.eof()) {
+          sat::literal_vector lits;
+          lits.reset();
+          if (c == '0') {
+            lits.push_back(sat::literal(indsup[k], true));
+          } else if (c == '1') {
+            lits.push_back(sat::literal(indsup[k], false));
+          } else {
+            printf("#%c,%d#", c, c);
+            abort();
+          }
+          solver.mk_clause(lits.size(), lits.c_ptr());
+
+          in >> c;
+          ++k;
+        }
+        lbool r = solver.check();
+        bool result = false;
+        switch (r) {
+          case l_true:
+            result = true;
+            break;
+          case l_undef:
+            std::cout << "unknown\n";
+            break;
+          case l_false:
+            break;
+        }
+
+        solver.user_pop(1);
+        struct timespec end;
+        clock_gettime(CLOCK_REALTIME, &end);
+        solver_time += duration(&start, &end);
+        return result;
+}
 
 unsigned read_dimacs(char const * file_name) {
     g_start_time = clock();
@@ -149,6 +209,156 @@ unsigned read_dimacs(char const * file_name) {
         parse_dimacs(std::cin, solver);
     }
     IF_VERBOSE(20, solver.display_status(verbose_stream()););
+
+    std::string s(file_name);
+    s += ".samples";
+    std::ifstream ifs(s);
+    std::string o(file_name);
+    o += ".samples.valid";
+    std::ofstream ofs(o);
+
+    int samples = 0;
+    int valid[7] = {0};
+    int invalid[7] = {0};
+    int total[7] = {0};
+    struct timespec initial;
+    clock_gettime(CLOCK_REALTIME, &initial);
+    srand(initial.tv_sec);
+
+    int count = 0;
+    int steps = 0;
+    for (std::string line; std::getline(ifs, line); ) {
+        ++count;
+        check_sample(solver, line);
+        if (count == 5) {
+            clock_gettime(CLOCK_REALTIME, &initial);
+            steps = 0;
+        }
+        ++steps;
+        if (count == 10) break;
+    }
+    struct timespec current;
+    clock_gettime(CLOCK_REALTIME, &current);
+    double step = duration(&initial, &current) / steps;
+    printf("Step %f s\n", step);
+    
+    ifs.clear();
+    ifs.seekg(0, std::ios::beg);
+
+    count = 0;
+    for (std::string line; std::getline(ifs, line); ) {
+        ++count;
+        int nmut = line[0] - '0';
+        ++total[nmut];
+    }
+
+    double timeout = 3600.0;
+
+    double probability = 1.0;
+
+    if (timeout / step < count) {
+        probability = (timeout / step) / count;
+    }
+    printf("Probability %f\n", probability);
+
+    double prob[7] = {0.0};
+    for (int i = 0; i < 7; ++i) {
+        int min = total[i] < 20 ? total[i] : 20;
+        if (total[i] * probability < min) {
+            prob[i] = (double)min / (double)total[i];
+            printf("prob[%d] = %f\n", i, prob[i]);
+        }
+    }
+
+    int calls = 0;
+
+    ifs.clear();
+    ifs.seekg(0, std::ios::beg);
+
+    clock_gettime(CLOCK_REALTIME, &initial);
+
+    for (std::string line; std::getline(ifs, line); ) {
+        int nmut = line[0] - '0';
+        bool run1 = rand() <= probability * RAND_MAX;
+        bool run2 = false;
+        if (prob[nmut])
+            run2 = rand() <= prob[nmut] * RAND_MAX;
+ 
+        bool result;
+        if (run1 || run2) {
+            auto search = hist.find(line.substr(3));
+            if (search != hist.end()) {
+                result = search->second.v;
+                if (run1) {
+                    ++search->second.c;
+                }
+            } else {
+                result = check_sample(solver, line);
+                calls += 1;
+                struct cell mycell;
+                mycell.c = run1? 1 : 0;
+                mycell.v = result;
+                hist.insert({line.substr(3), mycell});
+            }
+
+            if (result) {
+                ++valid[nmut];
+                ofs << "1\n";
+            } else {
+                ++invalid[nmut];
+                ofs << "0\n";
+            }
+            ++samples;
+        } else {
+            ofs << "?\n";
+        }
+    }
+    ifs.close();
+    ofs.close();
+    printf("Mutations\n");
+    double all_v = 0.0;
+    int all_t = 0;
+    for (int i = 0; i < 7; ++ i) {
+        printf("%d %d %d %d\n", i, valid[i], invalid[i], total[i]);
+        if (valid[i] + invalid[i])
+            all_v += (double)total[i] * (double)valid[i] / ((double)valid[i] + invalid[i]);
+        all_t += total[i];
+    }
+    printf("All\n");
+    printf("%f / %d = %f\n", all_v, all_t, all_v/all_t);
+
+    std::vector<int> good;
+    std::vector<int> bad;
+    for (const auto& it : hist) {
+        if (it.second.v) {
+            if (it.second.c >= good.size())
+                good.resize(it.second.c + 1);
+            ++good[it.second.c];
+        } else {
+            if (it.second.c >= bad.size())
+                bad.resize(it.second.c + 1);
+            ++bad[it.second.c];
+        }
+    }
+    printf("Valid\n");
+    count = 0;
+    for (auto v : good) {
+        printf("%d %d\n", count, v);
+        ++count;
+    }
+    printf("Invalid\n");
+    count = 0;
+    for (auto v : bad) {
+        printf("%d %d\n", count, v);
+        ++count;
+    }
+    clock_gettime(CLOCK_REALTIME, &current);
+    double total_time = duration(&initial, &current);
+    printf("Total %f s\n", total_time);
+    printf("Solver %f s\n", solver_time);
+    printf("Checked %d\n", samples);
+    printf("Calls %d\n", calls);
+    exit(0);
     
     lbool r;
     vector<sat::literal_vector> tracking_clauses;
-- 
2.7.4

